// Copyright 2019 Yunqi Ouyang
#include "cube_util/cube_333_solver.hpp"

#include "cube_util/move_sequence_nnn.hpp"

namespace cube_util {

using std::make_unique;
using std::max;
using std::min;
using std::fill;
using std::to_string;
using std::invalid_argument;
using std::runtime_error;

using cube333::kMaxPhase1Length;
using cube333::kMaxPhase2Length;
using cube333::kMaxCheckLength;
using cube333::kNEdgeFlip;
using cube333::kNCornerTwist;
using cube333::kNSlicePosition;
using cube333::kNCornerPerm;
using cube333::kNSliceEdgePerm;
using cube333::kNUd8EdgePerm;
using cube333::kSolvedCp;
using cube333::kSolvedFlip;
using cube333::kSolvedSlicePosition;
using cube333::kSolvedTwist;
using cube333::kSolvedUd8Ep;
using cube333::kSolvedSliceEp;
using cube333::kPhase2MoveCount;
using cube333::kPhase2Move;

using constants::kNAxis;
using constants::kMovePerAxis;
using constants::kInvalidAxis;

using utils::setPruning;
using utils::getPruning;
using utils::reverseMove;

Cube333Solver::Cube333Solver(const CubieCube333 &c) {
  cc_ = c;
}

int16_t Cube333Solver::getSolutionLength() const {
  return solution_length_;
}

/**
 * Iterating search function.
 * Try each depth to search for a solution.
 * @param maxLength how many moves in total is acceptable
 * @returns whether the cube is solved
 */
bool Cube333Solver::_solve(uint16_t maxLength) {
  // already solved and fulfills requirement
  if (solution_length_ >= 0 && solution_length_ <= maxLength) {
    return true;
  }

  phase1_length_ = -1;
  solution_length_ = -1;
  auto co = cc_.getCOIndex();
  auto eo = cc_.getEOIndex();
  auto slice = cc_.getSlicePositionIndex();

  auto upperBound = min(maxLength, kMaxPhase1Length);
  for (auto i = 0; i <= upperBound; i++) {
    if (phase1(co, eo, slice, i, kInvalidAxis, 0, maxLength)) {
      return true;
    }
  }
  return false;
}

/**
 * Phase1 searching function.
 * @param co corner orientation index to solve
 * @param eo edge orientation index to solve
 * @param slice E-slice edges positions index to solve
 * @param moveCount move count used to solve
 * @param lastAxis axis of last move
 * @param depth current search depth
 * @param maxLength how many moves in total is acceptable (including phase2)
 * @param checkOnly whether to check the cube is solvable only
 * @returns whether the cube is solved
 */
bool Cube333Solver::phase1(uint16_t co, uint16_t eo, uint16_t slice,
                           uint16_t moveCount, uint16_t lastAxis,
                           uint16_t depth, uint16_t maxLength, bool checkOnly) {
  if (moveCount == 0) {
    if (co == kSolvedCp && eo == kSolvedFlip &&
        slice == kSolvedSlicePosition) {
      if (checkOnly) {
        auto c = CubieCube333(cc_);
        for (auto i = 0; i < depth; i++) {
          c.move(solution_[i]);
        }
        return c == CubieCube333();
      }
      // phase1 solved
      phase1_length_ = depth;
      return initPhase2(lastAxis, depth, maxLength);
    }
    return false;
  }
  for (auto axis = 0; axis < kNAxis; axis++) {
    // we assume URF always show before DLB respectively
    if (axis != lastAxis && axis + 3 != lastAxis) {
      for (auto power = 0; power < kMovePerAxis; power++) {
        auto move = axis * kMovePerAxis + power;

        auto newCO = CubieCube333::getTwistMove(co, move);
        auto newEO = CubieCube333::getFlipMove(eo, move);
        auto newSlice = CubieCube333::getSlicePositionMove(slice, move);

        auto pruningValue = max(getTwistSlicePruning(newCO, newSlice),
                                getFlipSlicePruning(newEO, newSlice));

        // if the new state needs more than moveCount to solve,
        // it means any new state generated by the same axis
        // needs at least moveCount moves to solve, which is not
        // solvable in moveCount - 1 moves, so we can skip them.
        if (pruningValue > moveCount) {
          break;
        } else if (pruningValue == moveCount) {
          continue;
        }

        solution_[depth] = move;
        if (phase1(newCO, newEO, newSlice, moveCount - 1, axis, depth + 1,
                   maxLength, checkOnly)) {
          return true;
        }
      }
    }
  }
  return false;
}

/**
 * Initializing phase2.
 * @param lastAxis lastAxis of phase1, or a big number indicating last move
 * doesn't exist
 * @param depth current search depth (including phase1)
 * @param maxLength how many moves in total is acceptable (including phase1)
 * @returns whether the cube is solved
 */
bool Cube333Solver::initPhase2(uint16_t lastAxis, uint16_t depth,
                               uint16_t maxLength) {
  auto c = CubieCube333(cc_);
  for (auto i = 0; i < depth; i++) {
    c.move(solution_[i]);
  }

  auto cp = c.getCPIndex();
  auto ud8EP = c.getUD8EPIndex();
  auto sliceEP = c.getSliceEPIndex();

  // we wouldn't try any phase1 ends with phase2 moves unless
  // it's already totally solved
  if (depth > 0) {
    auto lastMove = solution_[depth - 1];
    for (auto i = 0; i < kPhase2MoveCount; i++) {
      if (lastMove == kPhase2Move[i]) {
        if (cp != kSolvedCp || ud8EP != kSolvedUd8Ep ||
            sliceEP != kSolvedSliceEp) {
          return false;
        }
        break;
      }
    }
  }

  auto upperBound = min(uint16_t(maxLength - depth), kMaxPhase2Length);
  for (auto i = 0; i <= upperBound; i++) {
    if (phase2(cp, ud8EP, sliceEP, i, lastAxis, depth)) {
      return true;
    }
  }
  return false;
}

/**
 * Phase2 searching function.
 * @param cp corner permutation index to solve
 * @param ud8EP UD 8 edges permutation index to solve
 * @param sliceEP E-slice edges permutation index to solve
 * @param moveCount move count used to solve
 * @param lastAxis axis of last move
 * @param depth current search depth
 * @returns whether the cube is solved
 */
bool Cube333Solver::phase2(
    uint16_t cp, uint16_t ud8EP, uint16_t sliceEP,
    uint16_t moveCount, uint16_t lastAxis, uint16_t depth) {
  if (moveCount == 0) {
    if (cp == kSolvedCp && ud8EP == kSolvedUd8Ep && sliceEP == kSolvedSliceEp) {
      solution_length_ = depth;
      return true;
    }
    return false;
  }
  for (auto i = 0; i < kPhase2MoveCount; i++) {
    auto move = kPhase2Move[i];
    auto axis = move / kMovePerAxis;
    // we assume URF always show before DLB respectively
    if (axis != lastAxis && axis + 3 != lastAxis) {
      auto newCP = CubieCube333::getCPMove(cp, i);
      auto newUD8EP = CubieCube333::getUD8EPMove(ud8EP, i);
      auto newSliceEP = CubieCube333::getSliceEPMove(sliceEP, i);

      auto pruningValue = max(getCPSliceEPPruning(newCP, newSliceEP),
                              getUD8EPSliceEPPruning(newUD8EP, newSliceEP));

      // since we are not iterating moves by axis here, we can not
      // utilize the same trick in phase1 elegantly here,
      // but it's still doable.
      if (pruningValue >= moveCount) {
        continue;
      }

      solution_[depth] = move;
      if (phase2(newCP, newUD8EP, newSliceEP, moveCount - 1, axis, depth + 1)) {
        return true;
      }
    }
  }
  return false;
}

unique_ptr<MoveSequence> Cube333Solver::solve(uint16_t maxLength) {
  if (!_solve(maxLength)) {
    throw runtime_error("not solved!");
  }
  vector<uint16_t> moves;
  for (auto i = 0; i < solution_length_; i++) {
    moves.push_back(solution_[i]);
  }
  return make_unique<MoveSequenceNNN>(3, moves);
}

unique_ptr<MoveSequence> Cube333Solver::generate(uint16_t maxLength) {
  if (!_solve(maxLength)) {
    throw runtime_error("not solved!");
  }
  vector<uint16_t> moves;
  for (auto i = solution_length_ - 1; i >= 0; i--) {
    moves.push_back(reverseMove(solution_[i]));
  }
  return make_unique<MoveSequenceNNN>(3, moves);
}

bool Cube333Solver::isSolvableIn(uint16_t maxLength) {
  if (maxLength > kMaxCheckLength) {
    throw invalid_argument("max check length is " + to_string(kMaxCheckLength));
  }
  if (solution_length_ >= 0 && solution_length_ <= maxLength) {
    return true;
  }

  auto coIndex = cc_.getCOIndex();
  auto eoIndex = cc_.getEOIndex();
  auto slicePositionIndex = cc_.getSlicePositionIndex();

  auto lowerBound = max(getTwistSlicePruning(coIndex, slicePositionIndex),
                        getFlipSlicePruning(eoIndex, slicePositionIndex));
  auto upperBound = maxLength;
  for (auto i = lowerBound; i <= upperBound; i++) {
    if (phase1(coIndex, eoIndex, slicePositionIndex, i, kInvalidAxis, 0,
               maxLength, true)) {
      return true;
    }
  }
  return false;
}

uint16_t Cube333Solver::getFlipSlicePruning(uint16_t flip, uint16_t slice) {
  static auto pruningTable = [] {
    const uint32_t totalCount = kNEdgeFlip * kNSlicePosition;
    auto ret = array<uint16_t, ((totalCount + 3) >> 2)>();
    fill(ret.begin(), ret.end(), 0xffff);
    uint32_t count = 0;
    for (auto depth = 0; count < totalCount; depth++) {
      if (depth == 0) {
        setPruning(&ret, kSolvedFlip * kNSlicePosition + kSolvedSlicePosition,
                   depth);
        count++;
        continue;
      }
      for (auto flip = 0; flip < kNEdgeFlip; flip++) {
        for (auto slice = 0; slice < kNSlicePosition; slice++) {
          auto index = flip * kNSlicePosition + slice;
          if (getPruning(ret, index) == depth - 1) {
            for (auto move = 0; move < kNMove; move++) {
              auto newFlip = CubieCube333::getFlipMove(flip, move);
              auto newSlice = CubieCube333::getSlicePositionMove(slice, move);
              auto newIndex = newFlip * kNSlicePosition + newSlice;
              if (getPruning(ret, newIndex) == 0xf) {
                setPruning(&ret, newIndex, depth);
                count++;
              }
            }
          }
        }
      }
    }
    return ret;
  }();
  return getPruning(pruningTable, flip * kNSlicePosition + slice);
}

uint16_t Cube333Solver::getTwistSlicePruning(uint16_t twist, uint16_t slice) {
  static auto pruningTable = [] {
    const uint32_t totalCount = kNCornerTwist * kNSlicePosition;
    auto ret = array<uint16_t, ((totalCount + 3) >> 2)>();
    fill(ret.begin(), ret.end(), 0xffff);
    uint32_t count = 0;
    for (auto depth = 0; count < totalCount; depth++) {
      if (depth == 0) {
        setPruning(&ret, kSolvedTwist * kNSlicePosition + kSolvedSlicePosition,
                   depth);
        count++;
        continue;
      }
      for (auto twist = 0; twist < kNCornerTwist; twist++) {
        for (auto slice = 0; slice < kNSlicePosition; slice++) {
          auto index = twist * kNSlicePosition + slice;
          if (getPruning(ret, index) == depth - 1) {
            for (auto move = 0; move < kNMove; move++) {
              auto newTwist = CubieCube333::getTwistMove(twist, move);
              auto newSlice = CubieCube333::getSlicePositionMove(slice, move);
              auto newIndex = newTwist * kNSlicePosition + newSlice;
              if (getPruning(ret, newIndex) == 0xf) {
                setPruning(&ret, newIndex, depth);
                count++;
              }
            }
          }
        }
      }
    }
    return ret;
  }();
  return getPruning(pruningTable, twist * kNSlicePosition + slice);
}

uint16_t Cube333Solver::getCPSliceEPPruning(uint16_t cp, uint16_t sliceEP) {
  static auto pruningTable = [] {
    const uint32_t totalCount = kNCornerPerm * kNSliceEdgePerm;
    auto ret = array<uint16_t, ((totalCount + 3) >> 2)>();
    fill(ret.begin(), ret.end(), 0xffff);
    uint32_t count = 0;
    for (auto depth = 0; count < totalCount; depth++) {
      if (depth == 0) {
        setPruning(&ret, kSolvedCp * kNSliceEdgePerm + kSolvedSliceEp,
                   depth);
        count++;
        continue;
      }
      for (auto cp = 0; cp < kNCornerPerm; cp++) {
        for (auto sliceEP = 0; sliceEP < kNSliceEdgePerm; sliceEP++) {
          auto index = cp * kNSliceEdgePerm + sliceEP;
          if (getPruning(ret, index) == depth - 1) {
            for (auto i = 0; i < kPhase2MoveCount; i++) {
              auto newCP = CubieCube333::getCPMove(cp, i);
              auto newSliceEP = CubieCube333::getSliceEPMove(sliceEP, i);
              auto newIndex = newCP * kNSliceEdgePerm + newSliceEP;
              if (getPruning(ret, newIndex) == 0xf) {
                setPruning(&ret, newIndex, depth);
                count++;
              }
            }
          }
        }
      }
    }
    return ret;
  }();
  return getPruning(pruningTable, cp * kNSliceEdgePerm + sliceEP);
}

uint16_t Cube333Solver::getUD8EPSliceEPPruning(uint16_t ud8EP,
                                               uint16_t sliceEP) {
  static auto pruningTable = [] {
    const uint32_t totalCount = kNUd8EdgePerm * kNSliceEdgePerm;
    auto ret = array<uint16_t, ((totalCount + 3) >> 2)>();
    fill(ret.begin(), ret.end(), 0xffff);
    uint32_t count = 0;
    for (auto depth = 0; count < totalCount; depth++) {
      if (depth == 0) {
        setPruning(&ret, kSolvedUd8Ep * kNSliceEdgePerm + kSolvedSliceEp,
                   depth);
        count++;
        continue;
      }
      for (auto ud8EP = 0; ud8EP < kNUd8EdgePerm; ud8EP++) {
        for (auto sliceEP = 0; sliceEP < kNSliceEdgePerm; sliceEP++) {
          auto index = ud8EP * kNSliceEdgePerm + sliceEP;
          if (getPruning(ret, index) == depth - 1) {
            for (auto i = 0; i < kPhase2MoveCount; i++) {
              auto newUD8EP = CubieCube333::getUD8EPMove(ud8EP, i);
              auto newSliceEP = CubieCube333::getSliceEPMove(sliceEP, i);
              auto newIndex = newUD8EP * kNSliceEdgePerm + newSliceEP;
              if (getPruning(ret, newIndex) == 0xf) {
                setPruning(&ret, newIndex, depth);
                count++;
              }
            }
          }
        }
      }
    }
    return ret;
  }();
  return getPruning(pruningTable, ud8EP * kNSliceEdgePerm + sliceEP);
}

}  // namespace cube_util
