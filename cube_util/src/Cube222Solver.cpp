// Copyright 2019 Yunqi Ouyang
#include<cube_util/Cube222Solver.hpp>
#include<memory>
#include<cube_util/MoveSequenceNNN.hpp>

namespace cube_util {

    using std::make_unique;

    using constants::N_AXIS;
    using constants::N_MOVE_PER_AXIS;
    using cube222::SOLVED_PERM;
    using cube222::SOLVED_TWIST;
    using cube222::N_MAX_LENGTH;

    using utils::getPruning;
    using utils::reverseMove;

    Cube222Solver::Cube222Solver(CubieCube222 c) {
        this->cc = c;
    }

    int16_t Cube222Solver::getSolutionLength() const {
        return solutionLength;
    }

    unique_ptr<MoveSequence> Cube222Solver::solve() {
        return this->solve(0);
    }

    unique_ptr<MoveSequence> Cube222Solver::solve(uint16_t minLength) {

        this->_solve(minLength);
        vector<uint16_t> moves;
        for (auto i = 0; i < this->solutionLength; i++) {
            moves.push_back(solution[i]);
        }
        return make_unique<MoveSequenceNNN>(2, moves);
    }

    unique_ptr<MoveSequence> Cube222Solver::generate() {
        return this->generate(0);
    }

    unique_ptr<MoveSequence> Cube222Solver::generate(uint16_t minLength) {
        this->_solve(minLength);
        vector<uint16_t> moves;
        for (auto i = this->solutionLength - 1; i >= 0; i--) {
            moves.push_back(reverseMove(solution[i]));
        }
        return make_unique<MoveSequenceNNN>(2, moves);
    }

    /**
     * Core searching function.
     * @param perm permutation index to solve
     * @param twist orientation index to solve
     * @param moveCount move count used to solve
     * @param lastAxis axis of last move
     * @param depth current search depth
     * @param saveSolution whether to save the solution
     * @returns whether the cube is solved
     */
    bool Cube222Solver::search(uint16_t perm, uint16_t twist,
        uint16_t moveCount, int16_t lastAxis, uint16_t depth,
        bool saveSolution) {
        if (moveCount == 0) {
            if (perm == SOLVED_PERM && twist == SOLVED_TWIST) {
                this->solutionLength = saveSolution ? depth : -1;
                return true;
            }
            return false;
        }
        for (auto axis = 0; axis < N_AXIS >> 1; axis++) {
            if (axis != lastAxis) {
                for (auto power = 0; power < N_MOVE_PER_AXIS; power++) {
                    auto move = axis * N_MOVE_PER_AXIS + power;
                    this->solution[depth] = move;
                    auto newPerm = CubieCube222::PERM_MOVE[perm][move];
                    auto newTwist = CubieCube222::TWIST_MOVE[twist][move];

                    // if the new state needs more than moveCount to solve,
                    // it means any new state generated by the same axis
                    // needs at least moveCount moves to solve, which is not
                    // solvable in moveCount - 1 moves, so we can skip them.
                    if (getPruning(PERM_PRUNING, newPerm) > moveCount ||
                        getPruning(TWIST_PRUNING, newTwist) > moveCount) {
                        break;
                    } else if (getPruning(PERM_PRUNING, newPerm) == moveCount ||
                        getPruning(TWIST_PRUNING, newTwist) == moveCount) {
                        continue;
                    }
                    if (search(newPerm, newTwist, moveCount - 1, axis,
                        depth + 1, saveSolution)) {
                        return true;
                    }
                }
            }
        }
        return false;
    }

    /**
     * Iterating search function.
     * Try each depth to search for a solution.
     * @param minLength minimal length to start
     */
    void Cube222Solver::_solve(uint16_t minLength) {
        if (minLength > N_MAX_LENGTH) {
            minLength = N_MAX_LENGTH;
        }

        const auto perm = cc.getCP();
        const auto twist = cc.getCO();
        for (auto i = minLength; i <= N_MAX_LENGTH; i++) {
            if (search(perm, twist, i, -1, 0, true)) {
                break;
            }
        }
    }

    bool Cube222Solver::isSolvableIn(uint16_t maxLength) {
        const auto perm = cc.getCP();
        const auto twist = cc.getCO();
        for (auto i = 0; i <= maxLength; i++) {
            if (search(perm, twist, i, -1, 0, false)) {
                return true;
            }
        }
        return false;
    }

}  // namespace cube_util
