// Copyright 2019 Yunqi Ouyang
#include<cube_util/Cube222Solver.hpp>
#include<cube_util/MoveSequenceNNN.hpp>

namespace cube_util {

    using std::make_unique;
    using std::fill;

    using constants::N_AXIS;
    using constants::N_MOVE_PER_AXIS;
    using cube222::SOLVED_PERM;
    using cube222::SOLVED_TWIST;

    using utils::setPruning;
    using utils::getPruning;
    using utils::reverseMove;

    Cube222Solver::Cube222Solver(CubieCube222 c) {
        this->cc = c;
    }

    int16_t Cube222Solver::getSolutionLength() const {
        return solutionLength;
    }

    unique_ptr<MoveSequence> Cube222Solver::solve() {
        return this->solve(0);
    }

    unique_ptr<MoveSequence> Cube222Solver::solve(uint16_t minLength) {
        this->_solve(minLength);
        vector<uint16_t> moves;
        for (auto i = 0; i < this->solutionLength; i++) {
            moves.push_back(solution[i]);
        }
        return make_unique<MoveSequenceNNN>(2, moves);
    }

    unique_ptr<MoveSequence> Cube222Solver::generate() {
        return this->generate(0);
    }

    unique_ptr<MoveSequence> Cube222Solver::generate(uint16_t minLength) {
        this->_solve(minLength);
        vector<uint16_t> moves;
        for (auto i = this->solutionLength - 1; i >= 0; i--) {
            moves.push_back(reverseMove(solution[i]));
        }
        return make_unique<MoveSequenceNNN>(2, moves);
    }

    /**
     * Core searching function.
     * @param perm permutation index to solve
     * @param twist orientation index to solve
     * @param moveCount move count used to solve
     * @param lastAxis axis of last move
     * @param depth current search depth
     * @param saveSolution whether to save the solution
     * @returns whether the cube is solved
     */
    bool Cube222Solver::search(uint16_t perm, uint16_t twist,
        uint16_t moveCount, int16_t lastAxis, uint16_t depth,
        bool saveSolution) {
        if (moveCount == 0) {
            if (perm == SOLVED_PERM && twist == SOLVED_TWIST) {
                solutionLength = saveSolution ? depth : -1;
                return true;
            }
            return false;
        }
        for (auto axis = 0; axis < N_AXIS >> 1; axis++) {
            if (axis != lastAxis) {
                for (auto power = 0; power < N_MOVE_PER_AXIS; power++) {
                    auto move = axis * N_MOVE_PER_AXIS + power;
                    solution[depth] = move;
                    auto newPerm = CubieCube222::getPermMove(perm, move);
                    auto newTwist = CubieCube222::getTwistMove(twist, move);

                    // if the new state needs more than moveCount to solve,
                    // it means any new state generated by the same axis
                    // needs at least moveCount moves to solve, which is not
                    // solvable in moveCount - 1 moves, so we can skip them.
                    if (getPermPruning(newPerm) > moveCount ||
                        getTwistPruning(newTwist) > moveCount) {
                        break;
                    } else if (
                        getPermPruning(newPerm) == moveCount ||
                        getTwistPruning(newTwist) == moveCount) {
                        continue;
                    }
                    if (search(newPerm, newTwist, moveCount - 1, axis,
                        depth + 1, saveSolution)) {
                        return true;
                    }
                }
            }
        }
        return false;
    }

    /**
     * Iterating search function.
     * Try each depth to search for a solution.
     * @param minLength minimal length to start
     */
    void Cube222Solver::_solve(uint16_t minLength) {
        if (minLength > N_MAX_LENGTH) {
            minLength = N_MAX_LENGTH;
        }

        const auto perm = cc.getCP();
        const auto twist = cc.getCO();
        for (auto i = minLength; i <= N_MAX_LENGTH; i++) {
            if (search(perm, twist, i, -1, 0, true)) {
                break;
            }
        }
    }

    bool Cube222Solver::isSolvableIn(uint16_t maxLength) {
        const auto perm = cc.getCP();
        const auto twist = cc.getCO();
        for (auto i = 0; i <= maxLength; i++) {
            if (search(perm, twist, i, -1, 0, false)) {
                return true;
            }
        }
        return false;
    }

    uint16_t Cube222Solver::getPermPruning(uint16_t perm) {
        static auto pruningTable = [] {
            auto ret = array<uint16_t, ((N_PERM + 3) >> 2)>();
            fill(ret.begin(), ret.end(), 0xffff);
            auto count = 0;
            for (auto depth = 0; count < N_PERM; depth++) {
                if (depth == 0) {
                    setPruning(&ret, SOLVED_PERM, depth);
                    count++;
                    continue;
                }
                for (auto perm = 0; perm < N_PERM; perm++) {
                    if (getPruning(ret, perm) == depth - 1) {
                        for (auto move = 0; move < N_MOVE; move++) {
                            auto newPerm =
                                CubieCube222::getPermMove(perm, move);
                            if (getPruning(ret, newPerm) == 0xf) {
                                setPruning(&ret, newPerm, depth);
                                count++;
                            }
                        }
                    }
                }
            }
            return ret;
        }();
        return getPruning(pruningTable, perm);
    }

    uint16_t Cube222Solver::getTwistPruning(uint16_t twist) {
        static auto pruningTable = [] {
            auto ret = array<uint16_t, ((N_TWIST + 3) >> 2)>();
            fill(ret.begin(), ret.end(), 0xffff);
            auto count = 0;
            for (auto depth = 0; count < N_TWIST; depth++) {
                if (depth == 0) {
                    setPruning(&ret, SOLVED_TWIST, depth);
                    count++;
                    continue;
                }
                for (auto twist = 0; twist < N_TWIST; twist++) {
                    if (getPruning(ret, twist) == depth - 1) {
                        for (auto move = 0; move < N_MOVE; move++) {
                            auto newTwist =
                                CubieCube222::getTwistMove(twist, move);
                            if (getPruning(ret, newTwist) == 0xf) {
                                setPruning(&ret, newTwist, depth);
                                count++;
                            }
                        }
                    }
                }
            }
            return ret;
        }();
        return getPruning(pruningTable, twist);
    }

}  // namespace cube_util
