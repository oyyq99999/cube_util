// Copyright 2019 Yunqi Ouyang
#include "cube_util/cube_222_solver.hpp"

#include "cube_util/move_sequence_nnn.hpp"

namespace cube_util {

using std::make_unique;
using std::fill;
using std::max;

using constants::kNAxis;
using constants::kMovePerAxis;
using constants::kInvalidAxis;
using cube222::kSolvedPerm;
using cube222::kSolvedTwist;

using utils::setPruning;
using utils::getPruning;
using utils::reverseMove;

Cube222Solver::Cube222Solver(const CubieCube222 &c) {
  cc_ = c;
}

int16_t Cube222Solver::getSolutionLength() const {
  return solution_length_;
}

unique_ptr<MoveSequence> Cube222Solver::solve(uint16_t minLength) {
  _solve(minLength);
  vector<uint16_t> moves;
  for (auto i = 0; i < solution_length_; i++) {
    moves.push_back(solution_[i]);
  }
  return make_unique<MoveSequenceNNN>(2, moves);
}

unique_ptr<MoveSequence> Cube222Solver::generate(uint16_t minLength) {
  _solve(minLength);
  vector<uint16_t> moves;
  for (auto i = solution_length_ - 1; i >= 0; i--) {
    moves.push_back(reverseMove(solution_[i]));
  }
  return make_unique<MoveSequenceNNN>(2, moves);
}

/**
 * Core searching function.
 * @param perm permutation index to solve
 * @param twist orientation index to solve
 * @param moveCount move count used to solve
 * @param lastAxis axis of last move
 * @param depth current search depth
 * @param saveSolution whether to save the solution
 * @returns whether the cube is solved
 */
bool Cube222Solver::search(
    uint16_t perm, uint16_t twist, uint16_t moveCount,
    uint16_t lastAxis, uint16_t depth, bool saveSolution) {
  if (moveCount == 0) {
    if (perm == kSolvedPerm && twist == kSolvedTwist) {
      solution_length_ = saveSolution ? depth : -1;
      return true;
    }
    return false;
  }
  for (auto axis = 0; axis < kNAxis >> 1; axis++) {
    if (axis != lastAxis) {
      for (auto power = 0; power < kMovePerAxis; power++) {
        auto move = axis * kMovePerAxis + power;
        solution_[depth] = move;
        auto newPerm = CubieCube222::getPermMove(perm, move);
        auto newTwist = CubieCube222::getTwistMove(twist, move);

        auto pruningValue = max(getPermPruning(newPerm),
                                getTwistPruning(newTwist));

        // if the new state needs more than moveCount to solve,
        // it means any new state generated by the same axis
        // needs at least moveCount moves to solve, which is not
        // solvable in moveCount - 1 moves, so we can skip them.
        if (pruningValue > moveCount) {
          break;
        } else if (pruningValue == moveCount) {
          continue;
        }
        if (search(newPerm, newTwist, moveCount - 1, axis, depth + 1,
                   saveSolution)) {
          return true;
        }
      }
    }
  }
  return false;
}

/**
 * Iterating search function.
 * Try each depth to search for a solution.
 * @param minLength minimal length to start
 */
void Cube222Solver::_solve(uint16_t minLength) {
  if (minLength > kMaxLength) {
    minLength = kMaxLength;
  }

  const auto perm = cc_.getCPIndex();
  const auto twist = cc_.getCOIndex();
  for (auto i = minLength; i <= kMaxLength; i++) {
    if (search(perm, twist, i, kInvalidAxis, 0, true)) {
      break;
    }
  }
}

bool Cube222Solver::isSolvableIn(uint16_t max_length) {
  const auto perm = cc_.getCPIndex();
  const auto twist = cc_.getCOIndex();
  for (auto i = 0; i <= max_length; i++) {
    if (search(perm, twist, i, kInvalidAxis, 0, false)) {
      return true;
    }
  }
  return false;
}

uint16_t Cube222Solver::getPermPruning(uint16_t perm) {
  static auto pruningTable = [] {
    auto ret = array<uint16_t, ((kNPerm + 3) >> 2)>();
    fill(ret.begin(), ret.end(), 0xffff);
    auto count = 0;
    for (auto depth = 0; count < kNPerm; depth++) {
      if (depth == 0) {
        setPruning(&ret, kSolvedPerm, depth);
        count++;
        continue;
      }
      for (auto perm = 0; perm < kNPerm; perm++) {
        if (getPruning(ret, perm) == depth - 1) {
          for (auto move = 0; move < kNMove; move++) {
            auto newPerm = CubieCube222::getPermMove(perm, move);
            if (getPruning(ret, newPerm) == 0xf) {
              setPruning(&ret, newPerm, depth);
              count++;
            }
          }
        }
      }
    }
    return ret;
  }();
  return getPruning(pruningTable, perm);
}

uint16_t Cube222Solver::getTwistPruning(uint16_t twist) {
  static auto pruningTable = [] {
    auto ret = array<uint16_t, ((kNTwist + 3) >> 2)>();
    fill(ret.begin(), ret.end(), 0xffff);
    auto count = 0;
    for (auto depth = 0; count < kNTwist; depth++) {
      if (depth == 0) {
        setPruning(&ret, kSolvedTwist, depth);
        count++;
        continue;
      }
      for (auto twist = 0; twist < kNTwist; twist++) {
        if (getPruning(ret, twist) == depth - 1) {
          for (auto move = 0; move < kNMove; move++) {
            auto newTwist = CubieCube222::getTwistMove(twist, move);
            if (getPruning(ret, newTwist) == 0xf) {
              setPruning(&ret, newTwist, depth);
              count++;
            }
          }
        }
      }
    }
    return ret;
  }();
  return getPruning(pruningTable, twist);
}

}  // namespace cube_util
